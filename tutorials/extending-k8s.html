<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Extending Kubernetes - Internal Developer Platform (IDP) Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Overview</li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../contributors.html"><strong aria-hidden="true">2.</strong> Contributors</a></li><li class="chapter-item expanded affix "><li class="part-title">Let's get started</li><li class="chapter-item expanded "><a href="../start/intro-to-k8s.html"><strong aria-hidden="true">3.</strong> Introduction to Kubernetes</a></li><li class="chapter-item expanded "><a href="../start/architecture-overview.html"><strong aria-hidden="true">4.</strong> Kubernetes Architecture</a></li><li class="chapter-item expanded "><a href="../start/pods.html"><strong aria-hidden="true">5.</strong> Kubernetes Pods</a></li><li class="chapter-item expanded "><a href="../start/set-up-cluster.html"><strong aria-hidden="true">6.</strong> Setup Kubernetes Cluster</a></li><li class="chapter-item expanded "><a href="../start/run-pod.html"><strong aria-hidden="true">7.</strong> Run Pods</a></li><li class="chapter-item expanded "><a href="../start/replicas.html"><strong aria-hidden="true">8.</strong> Replica Set</a></li><li class="chapter-item expanded "><a href="../start/deployment.html"><strong aria-hidden="true">9.</strong> Kubernetes Deployment</a></li><li class="chapter-item expanded "><a href="../start/namespaces.html"><strong aria-hidden="true">10.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../start/configmaps.html"><strong aria-hidden="true">11.</strong> ConfigMaps</a></li><li class="chapter-item expanded affix "><li class="part-title">Networking</li><li class="chapter-item expanded "><a href="../networking/service.html"><strong aria-hidden="true">12.</strong> Kubernetes Service</a></li><li class="chapter-item expanded "><a href="../networking/ingress.html"><strong aria-hidden="true">13.</strong> Kubernetes Ingress</a></li><li class="chapter-item expanded "><a href="../networking/servicemesh.html"><strong aria-hidden="true">14.</strong> Service Mesh</a></li><li class="chapter-item expanded affix "><li class="part-title">Storage</li><li class="chapter-item expanded "><a href="../storage/volumes.html"><strong aria-hidden="true">15.</strong> Kubernetes Volumes</a></li><li class="chapter-item expanded affix "><li class="part-title">Kubernetes Clusters Overview and Use</li><li class="chapter-item expanded "><a href="../kubernetes-clusters/kind.html"><strong aria-hidden="true">16.</strong> KinD Cluster</a></li><li class="chapter-item expanded "><a href="../kubernetes-clusters/k3s.html"><strong aria-hidden="true">17.</strong> K3s and K3sup</a></li><li class="chapter-item expanded affix "><li class="part-title">Templating & IaC</li><li class="chapter-item expanded "><a href="../templating/kustomize.html"><strong aria-hidden="true">18.</strong> Kustomize</a></li><li class="chapter-item expanded "><a href="../templating/terraform.html"><strong aria-hidden="true">19.</strong> Terraform</a></li><li class="chapter-item expanded "><a href="../templating/crossplane.html"><strong aria-hidden="true">20.</strong> Crossplane</a></li><li class="chapter-item expanded "><a href="../templating/crossplane-compositions.html"><strong aria-hidden="true">21.</strong> Crossplane Compositions</a></li><li class="chapter-item expanded "><a href="../templating/crossplane-composition-functions.html"><strong aria-hidden="true">22.</strong> Crossplane Composition Functions</a></li><li class="chapter-item expanded affix "><li class="part-title">Helm</li><li class="chapter-item expanded "><a href="../helm/partone.html"><strong aria-hidden="true">23.</strong> Helm Part 1</a></li><li class="chapter-item expanded "><a href="../helm/partwo.html"><strong aria-hidden="true">24.</strong> Helm Part 2</a></li><li class="chapter-item expanded "><a href="../helm/partthree.html"><strong aria-hidden="true">25.</strong> Helm Part 3</a></li><li class="chapter-item expanded affix "><li class="part-title">Cloud Native Tools and Platforms</li><li class="chapter-item expanded "><a href="../tools/k9s.html"><strong aria-hidden="true">26.</strong> k9s</a></li><li class="chapter-item expanded "><a href="../tools/knative.html"><strong aria-hidden="true">27.</strong> Knative</a></li><li class="chapter-item expanded "><a href="../tools/argocd.html"><strong aria-hidden="true">28.</strong> GitOps and Argo</a></li><li class="chapter-item expanded "><a href="../tools/linkerd.html"><strong aria-hidden="true">29.</strong> Linkerd</a></li><li class="chapter-item expanded affix "><li class="part-title">Observability</li><li class="chapter-item expanded "><a href="../observability/prometheus.html"><strong aria-hidden="true">30.</strong> Prometheus</a></li><li class="chapter-item expanded "><a href="../observability/prometheus-exporter.html"><strong aria-hidden="true">31.</strong> Prometheus Exporter</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="../advanced/operators.html"><strong aria-hidden="true">32.</strong> Kubernetes Operators</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials and Practice</li><li class="chapter-item expanded "><a href="../tutorials/extending-k8s.html" class="active"><strong aria-hidden="true">33.</strong> Extending Kubernetes</a></li><li class="chapter-item expanded "><a href="../tutorials/serverless.html"><strong aria-hidden="true">34.</strong> Serverless</a></li><li class="chapter-item expanded "><a href="../tutorials/ingress-from-scratch.html"><strong aria-hidden="true">35.</strong> Ingress from scratch</a></li><li class="chapter-item expanded "><a href="../tutorials/istio-from-scratch.html"><strong aria-hidden="true">36.</strong> Istio from scratch</a></li><li class="chapter-item expanded "><a href="../tutorials/deploy-to-civo.html"><strong aria-hidden="true">37.</strong> Deploy to CIVO</a></li><li class="chapter-item expanded affix "><li class="part-title">Troubleshooting K8s</li><li class="chapter-item expanded "><a href="../troubleshooting/crashloopbackoff.html"><strong aria-hidden="true">38.</strong> CrashLoopBackOff</a></li><li class="chapter-item expanded affix "><li class="part-title">Glossary</li><li class="chapter-item expanded "><a href="../glossary/terminologyprimer.html"><strong aria-hidden="true">39.</strong> Terminology Primer</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Internal Developer Platform (IDP) Book</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/roozy-io/idp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="extending-k8s-api-like-a-pro"><a class="header" href="#extending-k8s-api-like-a-pro">Extending k8s api like a pro.</a></h1>
<h1 id="links"><a class="header" href="#links">Links</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=">Video by Shahrooz Aghili</a></li>
</ul>
<h1 id="learning-resources"><a class="header" href="#learning-resources">Learning Resources</a></h1>
<ol>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/">Extending k8s</a></li>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom Resources</a></li>
</ol>
<h1 id="notes"><a class="header" href="#notes">Notes</a></h1>
<blockquote>
<p>Kubernetes is highly configurable and extensible. As a result, there is rarely a need to fork or submit patches to the Kubernetes project code.</p>
</blockquote>
<blockquote>
<p>Extension Points <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/#key-to-the-figure">Details</a>
<img src="../assets/extension-points.png" alt="k8s Extension Points" width="100%"></p>
</blockquote>
<h2 id="in-this-tutorial-we-will-be-focusing-on-extension-point-2-kubernetes-api"><a class="header" href="#in-this-tutorial-we-will-be-focusing-on-extension-point-2-kubernetes-api">In this tutorial we will be focusing on extension point 2 (Kubernetes API).</a></h2>
<table><thead><tr><th>Declarative APIs</th><th>Imperative APIs</th></tr></thead><tbody>
<tr><td>Your API consists of a relatively small number of relatively small objects (resources).</td><td>The client says &quot;do this&quot;, and then gets a synchronous response back when it is done.</td></tr>
<tr><td>The objects define configuration of applications or infrastructure.</td><td>The client says &quot;do this&quot;, and then gets an operation ID back, and has to check a separate Operation object to determine completion of the request.</td></tr>
<tr><td>The objects are updated relatively infrequently.</td><td>You talk about Remote Procedure Calls (RPCs).</td></tr>
<tr><td>Humans often need to read and write the objects.</td><td>Directly storing large amounts of data; for example, &gt; a few kB per object, or &gt; 1000s of objects.</td></tr>
<tr><td>The main operations on the objects are CRUD-y (creating, reading, updating and deleting).</td><td>High bandwidth access (10s of requests per second sustained) needed.</td></tr>
<tr><td>Transactions across objects are not required: the API represents a desired state, not an exact state.</td><td>Store end-user data (such as images, PII, etc.) or other large-scale data processed by applications.</td></tr>
<tr><td></td><td>The natural operations on the objects are not CRUD-y.</td></tr>
<tr><td></td><td>The API is not easily modeled as objects.</td></tr>
<tr><td></td><td>You chose to represent pending operations with an operation ID or an operation object.</td></tr>
</tbody></table>
<blockquote>
<p>Kubernetes is designed to be automated by writing client programs. Any program that reads and/or writes to the Kubernetes API can provide useful automation. Automation can run on the cluster or off it.</p>
</blockquote>
<blockquote>
<p>There is a specific pattern for writing client programs that work well with Kubernetes called the controller pattern. Controllers typically read an object's <code>.spec</code>, possibly do things, and then update the object's <code>.status</code>.</p>
</blockquote>
<pre><code class="language-shell">kind create cluster
</code></pre>
<p>let's start by using the <code>custom resource definition</code> api of kubernetes. 
let's create a custom resource called <code>CronTab</code></p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt; EOF
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;
  name: crontabs.stable.example.com
spec:
  # group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;
  group: stable.example.com
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v1
      # Each version can be enabled/disabled by Served flag.
      served: true
      # One and only one version must be marked as the storage version.
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                cronSpec:
                  type: string
                image:
                  type: string
                replicas:
                  type: integer
      
      additionalPrinterColumns:
        - name: Spec
        type: string
        description: The cron spec defining the interval a CronJob is run
        jsonPath: .spec.cronSpec
        - name: Replicas
        type: integer
        description: The number of jobs launched by the CronJob
        jsonPath: .spec.replicas
        - name: Age
        type: date
        jsonPath: .metadata.creationTimestamp
  # either Namespaced or Cluster
  scope: Namespaced
  names:
    # plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;
    plural: crontabs
    # singular name to be used as an alias on the CLI and for display
    singular: crontab
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: CronTab
    # shortNames allow shorter string to match your resource on the CLI
    shortNames:
    - ct
EOF
</code></pre>
<p>now our CronTab resource type is created. </p>
<pre><code class="language-shell">kubectl get crd
</code></pre>
<p>A new namespaced RESTful API endpoint is created at:</p>
<pre><code>/apis/stable.example.com/v1/namespaces/*/crontabs/...
</code></pre>
<p>Let's verify the k8s api extension by looking at the api server logs:</p>
<pre><code class="language-shell">kubectl -n kube-system logs -f kube-apiserver-kind-control-plane | grep example.com
</code></pre>
<p>Now we can create custom objects of our new custom resource defintion.
In the following example, the <code>cronSpec</code> and <code>image</code> custom fields are set in a custom object of kind <code>CronTab</code>. The kind <code>CronTab</code> comes from the <code>spec</code> of the CustomResourceDefinition object you created above.</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt; EOF
apiVersion: &quot;stable.example.com/v1&quot;
kind: CronTab
metadata:
  name: my-new-cron-object
spec:
  cronSpec: &quot;* * * * */5&quot;
  image: my-awesome-cron-image
EOF
</code></pre>
<pre><code class="language-shell">kubectl get crontab
</code></pre>
<p>Let's see how our object is being persisted at the etcd database of k8s.</p>
<pre><code class="language-shell">kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get / --prefix --keys-only&quot; | grep example.com

kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get /registry/apiextensions.k8s.io/customresourcedefinitions/crontabs.stable.example.com --prefix -w json&quot; | jq &quot;.kvs[0].value&quot; | cut -d '&quot;' -f2 | base64 --decode | yq &gt; crd.yml

kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get /registry/apiregistration.k8s.io/apiservices/v1.stable.example.com --prefix -w json&quot; | jq &quot;.kvs[0].value&quot; | cut -d '&quot;' -f2 | base64 --decode | yq &gt; api-registration.yml

kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get /registry/stable.example.com/crontabs/default/my-new-cron-object --prefix -w json&quot; | jq &quot;.kvs[0].value&quot; | cut -d '&quot;' -f2 | base64 --decode | yq &gt; mycron.yml
</code></pre>
<p>Delete custom resource </p>
<pre><code class="language-shell">kubectl delete CronTab my-new-cron-object
</code></pre>
<p>//TODO: add some text  why we need kubebuilder and what is an operator application and the relationship between a controller and an operator etc.
let's start by installing kubebuilder
//TODO: add kubebuilder to the killercoda</p>
<pre><code class="language-shell"># download kubebuilder and install locally.
curl -L -o kubebuilder &quot;https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)&quot;
chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/local/bin/
</code></pre>
<p>let's scaffold a kubebuilder application</p>
<pre><code class="language-shell">mkdir operator-tutorial
cd operator-tutorial
kubebuilder init --repo example.com
</code></pre>
<p>let's have a closer look at the make file first.
make targets are the commands that are used for different development lifecycle steps</p>
<pre><code class="language-shell">make help
</code></pre>
<p>to run your kubebuilder application locally</p>
<pre><code class="language-shell">make run
</code></pre>
<p>now let's have a look at the <code>run</code> target and all the prerequisite comamnds that need to run
it looks something like this</p>
<pre><code class="language-shell">.PHONY: run
run: manifests generate fmt vet ## Run a controller from your host.
	go run ./cmd/main.go
</code></pre>
<blockquote>
<p>so the targets that need to run before we can run our applications are </p>
<ol>
<li><code>manifests</code> and <code>generate</code> which both have controller-gen as prerequisite and generate some golang code and yaml manifests </li>
<li>the code is formatted by <code>fmt</code> </li>
<li>validated by <code>vet</code> </li>
<li>run will run the go application by refering to the application entrypoint at ./cmd/main.go </li>
</ol>
</blockquote>
<h2 id="now-we-have-a-working-yet-empty-go-application"><a class="header" href="#now-we-have-a-working-yet-empty-go-application">Now we have a working yet empty go application.</a></h2>
<p>let's add some meaningful code to it </p>
<p>Let's imagine we are a working at company where our colleagues are heavy users of the <code>ghost</code> blogging application.
Our job is to provide them with ghost instances whenever and whereever they want it. We are infra gurus and through years of
experience have learned that building an automation for such a task can save us a lot of toil and manual labor.</p>
<p>Our operator will take care of the following: </p>
<ol>
<li>create a new instance of the ghost application as a website in our cluster if our cluster doesn't have it already</li>
<li>update our ghost application when our ghost application custom resource is updated.</li>
<li>delete the ghost application upon request </li>
</ol>
<p>Kubebuilder provides a command that allows us to create a custom resource and a process that keeps maintaing (reconciling) that resouce.
If we choose to create a new resouces (let's call it <code>Ghost</code>) kubebuilder will create a blog controller for it automatically.
If we want to attach our own controllers to the exisiting k8s resources say <code>Pods</code> that's posssible too! :D </p>
<pre><code class="language-shell">kubebuilder create api \
  --kind Ghost \
  --group blog \
  --version v1 \
  --resource true \
  --controller true
</code></pre>
<p>At this stage, Kubebuilder has wired up two key components for your operator:</p>
<p>A Resource in the form of a Custom Resource Definition (CRD) with the kind <code>Ghost</code>.
A Controller that runs each time a <code>Ghost</code> CRD is create, changed, or deleted.</p>
<p>The command we ran added a Golang representation of the <code>Ghost</code> Custom Resource Definition (CRD) to our operator scaffolding code.
To view this code, navigate to your Code editor tab under <code>api</code> &gt; <code>v1</code> &gt; <code>ghost_types.go</code>.</p>
<p>Let's have a look at the <code>type GhostSpec struct</code>. 
This is the code definition of the Kubernetes object spec. This spec contains a field named <code>foo</code> which is defined in <code>api/v1/ghost_types.go:32</code>. 
There is even a helpful comment above the field describing the use of foo.</p>
<p>now let's see how kubebuilder can generate a yaml file for our <code>Custom Resource Definition</code></p>
<pre><code class="language-shell">make manifests
</code></pre>
<p>you will find the generated crd at <code>config/crd/bases/blog.example.com_ghosts.yaml</code>
see how kubebuilder did all the heavylifting we had to previously do for the crontab example! lovely!</p>
<h2 id="now-lets-install-the-crd-into-our-cluster"><a class="header" href="#now-lets-install-the-crd-into-our-cluster">Now let's install the CRD into our cluster</a></h2>
<p>let's notice the difference by looking at our kubernetes crds</p>
<pre><code class="language-shell">kubectl get crds
</code></pre>
<p>now let's install the crd we generated onto the cluster</p>
<pre><code class="language-shell">make install
</code></pre>
<p>and run the get the crds again</p>
<pre><code class="language-shell">kubectl get crds
</code></pre>
<h2 id="a-look-into-kubebuilder-setup"><a class="header" href="#a-look-into-kubebuilder-setup">A look into kubebuilder setup</a></h2>
<p>When you selected to create a operator along with the <code>Ghost</code> Resource, Kubebuilder took care of some key setup:</p>
<ol>
<li>Starts the operator process during application boot</li>
<li>Implements a custom Reconcile function to run on each <code>Ghost</code> resource event</li>
<li>Configures the operator to know which resource events to listen to</li>
</ol>
<p>To see the start process, navigate to <code>cmd/main.go:125</code>. You will see a section that starts the ghost operator:</p>
<pre><code class="language-shell">if err = (&amp;controllers.WebsiteReconciler{
  Client: mgr.GetClient(),
  Scheme: mgr.GetScheme(),
}).SetupWithManager(mgr); err != nil {
  setupLog.Error(err, &quot;unable to create controller&quot;, &quot;controller&quot;, &quot;Website&quot;)
  os.Exit(1)
}
</code></pre>
<p>This is a call to the function <code>SetupWithManager(mgr)</code> defined in the file <code>internal/controller/ghost_controller.go</code>.</p>
<p>Navigate to <code>internal/controller/ghost_controller.go:58</code> to view this function. 
It is already configured to know about the CRD <code>api/v1/ghost_types.go</code> or the generated yaml represenation at <code>crd/bases/blog.example.com_ghosts</code>.</p>
<p>The most important function inside the controller is the <code>Reconcile</code> function <code>internal/controller/ghost_controller.go:49</code>.  Reconcile is part of the main kubernetes reconciliation loop which aims to move the current state of the cluster closer to the desired state. It is triggered anytime we change the cluster state related to our custom resource <code>internal/controller/ghost_controller.go:49</code>.</p>
<h2 id="add-some-logging-to-the-reconcile-function"><a class="header" href="#add-some-logging-to-the-reconcile-function">add some logging to the reconcile function</a></h2>
<p>let's add some logs to the reconcile function and run the operator application and change the state of the cluster.
let's paste this code into the <code>Reconcile</code> function. </p>
<pre><code class="language-shell">  log := log.FromContext(ctx)
	log.Info(&quot;Reconciling Ghost&quot;)
	log.Info(&quot;Reconciliation complete&quot;)
	return ctrl.Result{}, nil
</code></pre>
<p>and run the application</p>
<pre><code class="language-shell">make run
</code></pre>
<p>next we need to modify the generated custom resource yaml file
navigate to <code>config/samples/blog_v1_ghost.yaml</code>
and add a <code>foo: bar</code> under spec. The custom resource should look like </p>
<pre><code class="language-shell">apiVersion: blog.example.com/v1
kind: Ghost
metadata:
  labels:
    app.kubernetes.io/name: ghost
    app.kubernetes.io/instance: ghost-sample
    app.kubernetes.io/part-of: operator-tutorial
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/created-by: operator-tutorial
  name: ghost-sample
spec:
  foo: bar
</code></pre>
<p>don't forget to save the file. Now in other terminal window, let's apply it on the cluster.</p>
<pre><code class="language-shell">kubectl apply -f config/samples/blog_v1_ghost.yaml
</code></pre>
<p>Tada! checkout the logs showing up!</p>
<pre><code class="language-shell">INFO    Reconciling Ghost
INFO    Reconciliation complete
</code></pre>
<p>now let's try deleting the resource. </p>
<pre><code class="language-shell">kubectl delete -f config/samples/blog_v1_ghost.yaml
</code></pre>
<p>Same logs showed up again. So basically <em>anytime</em> you interact with your <code>Ghost</code> resource a new event is triggered and your controller will print the logs. </p>
<h2 id="implementing-the-desire-state-of-the-ghost-operator"><a class="header" href="#implementing-the-desire-state-of-the-ghost-operator">implementing the desire state of the ghost operator</a></h2>
<p>Ok, now let's replace the default GhostSpec with a meaningful declartion of our desired state. Meaning we want our custom resource reflect the desired state for our Ghost application.</p>
<p>replace GhostSpec <code>api/v1/ghost_types.go:27</code> with the following snippet</p>
<pre><code class="language-shell">type GhostSpec struct {
	Team string `json:&quot;team,omitempty&quot;`
	//+kubebuilder:validation:Pattern=`^[-a-z0-9]*$`
	ImageTag string `json:&quot;imageTag&quot;`
}
</code></pre>
<p>This code has three key parts:</p>
<p>//+kubebuilder is a comment prefix that will trigger kubebuilder generation changes. In this case, it will set a validation of the <code>ImageTag</code> value to only allow dashes, lowercase letters, or digits.
The <code>ImageTag</code> is the Golang variable used throughout the codebase. Golang uses capitalized public variable names by convention.
<code>json:&quot;imageTag&quot;</code> defines a &quot;tag&quot; that Kubebuilder uses to generate the YAML field. Yaml parameters starts with lower case variable names by convention.
If <code>omitempty</code> is used in a json tag, that field will be marked as <code>optional</code>, otherwise as <code>mandatory</code>.</p>
<p>Before we generete the new crd and install them on the cluster let's do the following, let's have a look at the existing crd</p>
<pre><code class="language-shell">kubectl get crd ghosts.blog.example.com --output jsonpath=&quot;{.spec.versions[0].schema['openAPIV3Schema'].properties.spec.properties}{\&quot;\n\&quot;}&quot; | jq
</code></pre>
<p>the output should be like </p>
<pre><code class="language-shell">{
  &quot;foo&quot;: {
    &quot;description&quot;: &quot;Foo is an example field of Ghost. Edit ghost_types.go to remove/update&quot;,
    &quot;type&quot;: &quot;string&quot;
  }
}
</code></pre>
<p>now, let us install the new crd</p>
<pre><code class="language-shell">make install
</code></pre>
<p>and see the changes</p>
<pre><code class="language-shell">kubectl get crd ghosts.blog.example.com --output jsonpath=&quot;{.spec.versions[0].schema['openAPIV3Schema'].properties.spec.properties}{\&quot;\n\&quot;}&quot; | jq
</code></pre>
<p>the output should be </p>
<pre><code class="language-shell">{
  &quot;imageTag&quot;: {
    &quot;pattern&quot;: &quot;^[-a-z0-9]*$&quot;,
    &quot;type&quot;: &quot;string&quot;
  },
  &quot;team&quot;: {
    &quot;type&quot;: &quot;string&quot;
  }
}
</code></pre>
<h2 id="accessing-the-our-custom-resource-inside-the-reconcile-function"><a class="header" href="#accessing-the-our-custom-resource-inside-the-reconcile-function">accessing the our custom resource inside the reconcile function</a></h2>
<p>now let's try to access our custom resource in the <code>reconcile</code> function. 
first off, let us reflect our new fields in our cutom resource.
let us replace <code>config/samples/blog_v1_ghost.yaml</code> with the following</p>
<pre><code class="language-shell">apiVersion: blog.example.com/v1
kind: Ghost
metadata:
  labels:
    app.kubernetes.io/name: ghost
    app.kubernetes.io/instance: ghost-sample
    app.kubernetes.io/part-of: operator-tutorial
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/created-by: operator-tutorial
  name: ghost-sample
spec:
  imageTag: latest
  team: marketing
</code></pre>
<p>next, let us replace the <code>reconcile</code> code with the following snippet: </p>
<pre><code class="language-shell">log := log.FromContext(ctx)
ghost := &amp;blogv1.Ghost{}
if err := r.Get(ctx, req.NamespacedName, ghost); err != nil {
  log.Error(err, &quot;Failed to get Ghost&quot;)
  return ctrl.Result{}, client.IgnoreNotFound(err)
}

log.Info(&quot;Reconciling Ghost&quot;, &quot;imageTag&quot;, ghost.Spec.ImageTag, &quot;team&quot;, ghost.Spec.Team)
log.Info(&quot;Reconciliation complete&quot;)
return ctrl.Result{}, nil
</code></pre>
<p>let us anlyze the above snippet line by line. 
line 1 assings a logger instance to the variable <code>log</code> variable.
line 2 creates an instance of our <code>Ghost</code> data structure.
line 3 tries to read a ghost instance from the reconciler client. Please note that the r which is a reference to the <code>GhostReconciler</code> has a k8s client interface and that interface which implements the <code>Get</code> method which is an equivalent golang implementation of the <code>kubectl get</code>. on succesful <code>Get</code> the resouce will be written to our <code>ghost</code> variable. in case of error, client logs the error. if the error is of type (not found) the controller won't return an error. error not found will happen if we run <code>kubectl delete -f config/samples/blog_v1_ghost.yaml</code></p>
<p>now we can start our application again:</p>
<pre><code class="language-shell">make run
</code></pre>
<p>so far our reconcile function is not run yet but if we apply our custom resource in another terminal window:</p>
<pre><code class="language-shell">kubectl apply -f config/crd/samples/blog_v1_ghost.yaml
</code></pre>
<p>we start to see the logs of our reconcile function</p>
<pre><code class="language-shell">INFO    Reconciling Ghost       {&quot;controller&quot;: &quot;ghost&quot;, &quot;controllerGroup&quot;: &quot;blog.example.com&quot;, &quot;controllerKind&quot;: &quot;Ghost&quot;, &quot;Ghost&quot;: {&quot;name&quot;:&quot;ghost-sample&quot;,&quot;namespace&quot;:&quot;default&quot;}, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;ghost-sample&quot;, &quot;reconcileID&quot;: &quot;9faf1c4f-6dcf-42d5-9f16-fbebb453b4ed&quot;, &quot;imageTag&quot;: &quot;latest&quot;, &quot;team&quot;: &quot;marketing&quot;}
2024-04-29T15:54:05+02:00       

INFO    Reconciliation complete {&quot;controller&quot;: &quot;ghost&quot;, &quot;controllerGroup&quot;: &quot;blog.example.com&quot;, &quot;controllerKind&quot;: &quot;Ghost&quot;, &quot;Ghost&quot;: {&quot;name&quot;:&quot;ghost-sample&quot;,&quot;namespace&quot;:&quot;default&quot;}, &quot;namespace&quot;: &quot;default&quot;, &quot;name&quot;: &quot;ghost-sample&quot;, &quot;reconcileID&quot;: &quot;9faf1c4f-6dcf-42d5-9f16-fbebb453b4ed&quot;}
</code></pre>
<p>cool! next stop, we will implement the actual controller logic for our ghost operator.</p>
<h2 id="implementing-the-ghost-operator-logic"><a class="header" href="#implementing-the-ghost-operator-logic">implementing the ghost operator logic</a></h2>
<p>Before we start coding the ghost operator, we need to know what resources we need in order to deploy ghost to our cluster. let's consult the docker hub page for ghost. https://hub.docker.com/_/ghost</p>
<p>As we would like to persist ghost data to a persistent volume, we can try to convert this docker command to a k8s deployment. </p>
<pre><code class="language-shell">docker run -d \
	--name some-ghost \
	-e NODE_ENV=development \
	-e database__connection__filename='/var/lib/ghost/content/data/ghost.db' \
	-p 3001:2368 \
	-v some-ghost-data:/var/lib/ghost/content \
	ghost:alpine
</code></pre>
<p>The deployment would look something like </p>
<pre><code class="language-shell">apiVersion: apps/v1
kind: Deployment
metadata:
  name: ghost-deployment
spec:
  replicas: 1 # You can adjust the number of replicas as needed
  selector:
    matchLabels:
      app: ghost
  template:
    metadata:
      labels:
        app: ghost
    spec:
      containers:
      - name: ghost
        image: ghost:alpine
        env:
        - name: NODE_ENV
          value: development
        - name: database__connection__filename
          value: /var/lib/ghost/content/data/ghost.db
        ports:
        - containerPort: 2368
        volumeMounts:
        - name: ghost-data
          mountPath: /var/lib/ghost/content
      volumes:
      - name: ghost-data
        persistentVolumeClaim:
          claimName: ghost-data-pvc # Define your PVC or use an existing one
</code></pre>
<p>As you can see this deployment expects an existing persistent volume claim called <code>ghost-data-pvc</code></p>
<p>We can define it with this yaml:</p>
<pre><code class="language-shell">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ghost-data-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
</code></pre>
<p>Let us try to code the pvc provisiong into our controller.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../advanced/operators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../tutorials/serverless.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../advanced/operators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../tutorials/serverless.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
