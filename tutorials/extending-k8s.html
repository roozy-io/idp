<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Extending Kubernetes - Internal Developer Platform (IDP) Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Overview</li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../contributors.html"><strong aria-hidden="true">2.</strong> Contributors</a></li><li class="chapter-item expanded affix "><li class="part-title">Let's get started</li><li class="chapter-item expanded "><a href="../start/intro-to-k8s.html"><strong aria-hidden="true">3.</strong> Introduction to Kubernetes</a></li><li class="chapter-item expanded "><a href="../start/architecture-overview.html"><strong aria-hidden="true">4.</strong> Kubernetes Architecture</a></li><li class="chapter-item expanded "><a href="../start/pods.html"><strong aria-hidden="true">5.</strong> Kubernetes Pods</a></li><li class="chapter-item expanded "><a href="../start/set-up-cluster.html"><strong aria-hidden="true">6.</strong> Setup Kubernetes Cluster</a></li><li class="chapter-item expanded "><a href="../start/run-pod.html"><strong aria-hidden="true">7.</strong> Run Pods</a></li><li class="chapter-item expanded "><a href="../start/replicas.html"><strong aria-hidden="true">8.</strong> Replica Set</a></li><li class="chapter-item expanded "><a href="../start/deployment.html"><strong aria-hidden="true">9.</strong> Kubernetes Deployment</a></li><li class="chapter-item expanded "><a href="../start/namespaces.html"><strong aria-hidden="true">10.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../start/configmaps.html"><strong aria-hidden="true">11.</strong> ConfigMaps</a></li><li class="chapter-item expanded affix "><li class="part-title">Networking</li><li class="chapter-item expanded "><a href="../networking/service.html"><strong aria-hidden="true">12.</strong> Kubernetes Service</a></li><li class="chapter-item expanded "><a href="../networking/ingress.html"><strong aria-hidden="true">13.</strong> Kubernetes Ingress</a></li><li class="chapter-item expanded "><a href="../networking/servicemesh.html"><strong aria-hidden="true">14.</strong> Service Mesh</a></li><li class="chapter-item expanded affix "><li class="part-title">Storage</li><li class="chapter-item expanded "><a href="../storage/volumes.html"><strong aria-hidden="true">15.</strong> Kubernetes Volumes</a></li><li class="chapter-item expanded affix "><li class="part-title">Kubernetes Clusters Overview and Use</li><li class="chapter-item expanded "><a href="../kubernetes-clusters/kind.html"><strong aria-hidden="true">16.</strong> KinD Cluster</a></li><li class="chapter-item expanded "><a href="../kubernetes-clusters/k3s.html"><strong aria-hidden="true">17.</strong> K3s and K3sup</a></li><li class="chapter-item expanded affix "><li class="part-title">Templating & IaC</li><li class="chapter-item expanded "><a href="../templating/kustomize.html"><strong aria-hidden="true">18.</strong> Kustomize</a></li><li class="chapter-item expanded "><a href="../templating/terraform.html"><strong aria-hidden="true">19.</strong> Terraform</a></li><li class="chapter-item expanded "><a href="../templating/crossplane.html"><strong aria-hidden="true">20.</strong> Crossplane</a></li><li class="chapter-item expanded "><a href="../templating/crossplane-compositions.html"><strong aria-hidden="true">21.</strong> Crossplane Compositions</a></li><li class="chapter-item expanded "><a href="../templating/crossplane-composition-functions.html"><strong aria-hidden="true">22.</strong> Crossplane Composition Functions</a></li><li class="chapter-item expanded affix "><li class="part-title">Helm</li><li class="chapter-item expanded "><a href="../helm/partone.html"><strong aria-hidden="true">23.</strong> Helm Part 1</a></li><li class="chapter-item expanded "><a href="../helm/partwo.html"><strong aria-hidden="true">24.</strong> Helm Part 2</a></li><li class="chapter-item expanded "><a href="../helm/partthree.html"><strong aria-hidden="true">25.</strong> Helm Part 3</a></li><li class="chapter-item expanded affix "><li class="part-title">Cloud Native Tools and Platforms</li><li class="chapter-item expanded "><a href="../tools/k9s.html"><strong aria-hidden="true">26.</strong> k9s</a></li><li class="chapter-item expanded "><a href="../tools/knative.html"><strong aria-hidden="true">27.</strong> Knative</a></li><li class="chapter-item expanded "><a href="../tools/argocd.html"><strong aria-hidden="true">28.</strong> GitOps and Argo</a></li><li class="chapter-item expanded "><a href="../tools/linkerd.html"><strong aria-hidden="true">29.</strong> Linkerd</a></li><li class="chapter-item expanded affix "><li class="part-title">Observability</li><li class="chapter-item expanded "><a href="../observability/prometheus.html"><strong aria-hidden="true">30.</strong> Prometheus</a></li><li class="chapter-item expanded "><a href="../observability/prometheus-exporter.html"><strong aria-hidden="true">31.</strong> Prometheus Exporter</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="../advanced/operators.html"><strong aria-hidden="true">32.</strong> Kubernetes Operators</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials and Practice</li><li class="chapter-item expanded "><a href="../tutorials/extending-k8s.html" class="active"><strong aria-hidden="true">33.</strong> Extending Kubernetes</a></li><li class="chapter-item expanded "><a href="../tutorials/serverless.html"><strong aria-hidden="true">34.</strong> Serverless</a></li><li class="chapter-item expanded "><a href="../tutorials/ingress-from-scratch.html"><strong aria-hidden="true">35.</strong> Ingress from scratch</a></li><li class="chapter-item expanded "><a href="../tutorials/istio-from-scratch.html"><strong aria-hidden="true">36.</strong> Istio from scratch</a></li><li class="chapter-item expanded "><a href="../tutorials/deploy-to-civo.html"><strong aria-hidden="true">37.</strong> Deploy to CIVO</a></li><li class="chapter-item expanded affix "><li class="part-title">Troubleshooting K8s</li><li class="chapter-item expanded "><a href="../troubleshooting/crashloopbackoff.html"><strong aria-hidden="true">38.</strong> CrashLoopBackOff</a></li><li class="chapter-item expanded affix "><li class="part-title">Glossary</li><li class="chapter-item expanded "><a href="../glossary/terminologyprimer.html"><strong aria-hidden="true">39.</strong> Terminology Primer</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Internal Developer Platform (IDP) Book</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/roozy-io/idp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="extending-k8s-api-like-a-pro"><a class="header" href="#extending-k8s-api-like-a-pro">Extending k8s api like a pro.</a></h1>
<h1 id="links"><a class="header" href="#links">Links</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=">Video by Shahrooz Aghili</a></li>
</ul>
<h1 id="learning-resources"><a class="header" href="#learning-resources">Learning Resources</a></h1>
<ol>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/">Extending k8s</a></li>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom Resources</a></li>
</ol>
<h1 id="notes"><a class="header" href="#notes">Notes</a></h1>
<blockquote>
<p>Kubernetes is highly configurable and extensible. As a result, there is rarely a need to fork or submit patches to the Kubernetes project code.</p>
</blockquote>
<blockquote>
<p>Extension Points <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/#key-to-the-figure">Details</a>
<img src="../assets/extension-points.png" alt="k8s Extension Points" width="100%"></p>
</blockquote>
<h2 id="1-a-look-into-custom-resource-definition-crd-api"><a class="header" href="#1-a-look-into-custom-resource-definition-crd-api">1. A Look into Custom Resource Definition (CRD) API</a></h2>
<table><thead><tr><th>Declarative APIs</th><th>Imperative APIs</th></tr></thead><tbody>
<tr><td>Your API consists of a relatively small number of relatively small objects (resources).</td><td>The client says &quot;do this&quot;, and then gets a synchronous response back when it is done.</td></tr>
<tr><td>The objects define configuration of applications or infrastructure.</td><td>The client says &quot;do this&quot;, and then gets an operation ID back, and has to check a separate Operation object to determine completion of the request.</td></tr>
<tr><td>The objects are updated relatively infrequently.</td><td>You talk about Remote Procedure Calls (RPCs).</td></tr>
<tr><td>Humans often need to read and write the objects.</td><td>Directly storing large amounts of data; for example, &gt; a few kB per object, or &gt; 1000s of objects.</td></tr>
<tr><td>The main operations on the objects are CRUD-y (creating, reading, updating and deleting).</td><td>High bandwidth access (10s of requests per second sustained) needed.</td></tr>
<tr><td>Transactions across objects are not required: the API represents a desired state, not an exact state.</td><td>Store end-user data (such as images, PII, etc.) or other large-scale data processed by applications.</td></tr>
<tr><td></td><td>The natural operations on the objects are not CRUD-y.</td></tr>
<tr><td></td><td>The API is not easily modeled as objects.</td></tr>
<tr><td></td><td>You chose to represent pending operations with an operation ID or an operation object.</td></tr>
</tbody></table>
<blockquote>
<p>Kubernetes is designed to be automated by writing client programs. Any program that reads and/or writes to the Kubernetes API can provide useful automation. Automation can run on the cluster or off it.</p>
</blockquote>
<blockquote>
<p>There is a specific pattern for writing client programs that work well with Kubernetes called the controller pattern. Controllers typically read an object's <code>.spec</code>, possibly do things, and then update the object's <code>.status</code>.</p>
</blockquote>
<pre><code class="language-shell">kind create cluster
</code></pre>
<p>let's start by using the <code>custom resource definition</code> api of kubernetes. 
let's create a custom resource called <code>CronTab</code></p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt; EOF
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  # name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;
  name: crontabs.stable.example.com
spec:
  # group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;
  group: stable.example.com
  # list of versions supported by this CustomResourceDefinition
  versions:
    - name: v1
      # Each version can be enabled/disabled by Served flag.
      served: true
      # One and only one version must be marked as the storage version.
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                cronSpec:
                  type: string
                image:
                  type: string
                replicas:
                  type: integer
      
      additionalPrinterColumns:
        - name: Spec
        type: string
        description: The cron spec defining the interval a CronJob is run
        jsonPath: .spec.cronSpec
        - name: Replicas
        type: integer
        description: The number of jobs launched by the CronJob
        jsonPath: .spec.replicas
        - name: Age
        type: date
        jsonPath: .metadata.creationTimestamp
  # either Namespaced or Cluster
  scope: Namespaced
  names:
    # plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;
    plural: crontabs
    # singular name to be used as an alias on the CLI and for display
    singular: crontab
    # kind is normally the CamelCased singular type. Your resource manifests use this.
    kind: CronTab
    # shortNames allow shorter string to match your resource on the CLI
    shortNames:
    - ct
EOF
</code></pre>
<p>now our CronTab resource type is created. </p>
<pre><code class="language-shell">kubectl get crd
</code></pre>
<p>A new namespaced RESTful API endpoint is created at:</p>
<pre><code>/apis/stable.example.com/v1/namespaces/*/crontabs/...
</code></pre>
<p>Let's verify the k8s api extension by looking at the api server logs:</p>
<pre><code class="language-shell">kubectl -n kube-system logs -f kube-apiserver-kind-control-plane | grep example.com
</code></pre>
<p>Now we can create custom objects of our new custom resource defintion.
In the following example, the <code>cronSpec</code> and <code>image</code> custom fields are set in a custom object of kind <code>CronTab</code>. The kind <code>CronTab</code> comes from the <code>spec</code> of the CustomResourceDefinition object you created above.</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt; EOF
apiVersion: &quot;stable.example.com/v1&quot;
kind: CronTab
metadata:
  name: my-new-cron-object
spec:
  cronSpec: &quot;* * * * */5&quot;
  image: my-awesome-cron-image
EOF
</code></pre>
<pre><code class="language-shell">kubectl get crontab
</code></pre>
<p>Let's see how our object is being persisted at the etcd database of k8s.</p>
<pre><code class="language-shell">kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get / --prefix --keys-only&quot; | grep example.com

kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get /registry/apiextensions.k8s.io/customresourcedefinitions/crontabs.stable.example.com --prefix -w json&quot; | jq &quot;.kvs[0].value&quot; | cut -d '&quot;' -f2 | base64 --decode | yq &gt; crd.yml

kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get /registry/apiregistration.k8s.io/apiservices/v1.stable.example.com --prefix -w json&quot; | jq &quot;.kvs[0].value&quot; | cut -d '&quot;' -f2 | base64 --decode | yq &gt; api-registration.yml

kubectl exec etcd-kind-control-plane -n kube-system -- sh -c &quot;ETCDCTL_API=3 etcdctl --cacert /etc/kubernetes/pki/etcd/ca.crt  --key /etc/kubernetes/pki/etcd/server.key --cert  /etc/kubernetes/pki/etcd/server.crt  get /registry/stable.example.com/crontabs/default/my-new-cron-object --prefix -w json&quot; | jq &quot;.kvs[0].value&quot; | cut -d '&quot;' -f2 | base64 --decode | yq &gt; mycron.yml
</code></pre>
<p>Delete custom resource </p>
<pre><code class="language-shell">kubectl delete CronTab my-new-cron-object
</code></pre>
<p>//TODO: add some text  why we need kubebuilder and what is an operator application and the relationship between a controller and an operator etc.</p>
<h2 id="2-install-kubebuilder-and-create-a-new-project"><a class="header" href="#2-install-kubebuilder-and-create-a-new-project">2. Install Kubebuilder and Create a New Project</a></h2>
<p>let's start by installing kubebuilder</p>
<pre><code class="language-shell"># download kubebuilder and install locally.
curl -L -o kubebuilder &quot;https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)&quot;
chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/local/bin/
</code></pre>
<p>let's scaffold a kubebuilder application</p>
<pre><code class="language-shell">mkdir operator-tutorial
cd operator-tutorial
kubebuilder init --repo example.com
</code></pre>
<p>let's have a closer look at the make file first.
make targets are the commands that are used for different development lifecycle steps</p>
<pre><code class="language-shell">make help
</code></pre>
<p>to run your kubebuilder application locally</p>
<pre><code class="language-shell">make run
</code></pre>
<p>now let's have a look at the <code>run</code> target and all the prerequisite comamnds that need to run
it looks something like this</p>
<pre><code class="language-shell">.PHONY: run
run: manifests generate fmt vet ## Run a controller from your host.
	go run ./cmd/main.go
</code></pre>
<blockquote>
<p>so the targets that need to run before we can run our applications are </p>
<ol>
<li><code>manifests</code> and <code>generate</code> which both have controller-gen as prerequisite and generate some golang code and yaml manifests </li>
<li>the code is formatted by <code>fmt</code> </li>
<li>validated by <code>vet</code> </li>
<li><code>run</code> will run the go application by refering to the application entrypoint at ./cmd/main.go </li>
</ol>
</blockquote>
<h2 id="3-create-our-first-api"><a class="header" href="#3-create-our-first-api">3. Create Our First API</a></h2>
<p>Let's imagine we are a working at company where our colleagues are heavy users of the <code>ghost</code> blogging application.
Our job is to provide them with ghost instances whenever and whereever they want it. We are infra gurus and through years of
experience have learned that building an automation for such a task can save us a lot of toil and manual labor.</p>
<p>Our operator will take care of the following: </p>
<ol>
<li>create a new instance of the ghost application as a website in our cluster if our cluster doesn't have it already</li>
<li>update our ghost application when our ghost application custom resource is updated.</li>
<li>delete the ghost application upon request </li>
</ol>
<p>Kubebuilder provides a command that allows us to create a custom resource and a process that keeps maintaing (reconciling) that resouce.
If we choose to create a new resouces (let's call it <code>Ghost</code>) kubebuilder will create a blog controller for it automatically.
If we want to attach our own controllers to the exisiting k8s resources say <code>Pods</code> that's posssible too! :D </p>
<pre><code class="language-shell">kubebuilder create api \
  --kind Ghost \
  --group blog \
  --version v1 \
  --resource true \
  --controller true
</code></pre>
<p>At this stage, Kubebuilder has wired up two key components for your operator:</p>
<p>A Resource in the form of a Custom Resource Definition (CRD) with the kind <code>Ghost</code>.
A Controller that runs each time a <code>Ghost</code> CRD is create, changed, or deleted.</p>
<p>The command we ran added a Golang representation of the <code>Ghost</code> Custom Resource Definition (CRD) to our operator scaffolding code.
To view this code, navigate to your Code editor tab under <code>api</code> &gt; <code>v1</code> &gt; <code>ghost_types.go</code>.</p>
<p>Let's have a look at the <code>type GhostSpec struct</code>. 
This is the code definition of the Kubernetes object spec. This spec contains a field named <code>foo</code> which is defined in <code>api/v1/ghost_types.go:32</code>. 
There is even a helpful comment above the field describing the use of foo.</p>
<p>now let's see how kubebuilder can generate a yaml file for our <code>Custom Resource Definition</code></p>
<pre><code class="language-shell">make manifests
</code></pre>
<p>you will find the generated crd at <code>config/crd/bases/blog.example.com_ghosts.yaml</code>
see how kubebuilder did all the heavylifting we had to previously do for the crontab example! lovely!</p>
<p>let's notice the difference by looking at our kubernetes crds</p>
<pre><code class="language-shell">kubectl get crds
</code></pre>
<p>now let's install the crd we generated onto the cluster</p>
<pre><code class="language-shell">make install
</code></pre>
<p>and run the get the crds again</p>
<pre><code class="language-shell">kubectl get crds
</code></pre>
<h2 id="4-a-look-into-kubebuilder-setup"><a class="header" href="#4-a-look-into-kubebuilder-setup">4. A look into kubebuilder setup</a></h2>
<p>When you selected to create a operator along with the <code>Ghost</code> Resource, Kubebuilder took care of some key setup:</p>
<ol>
<li>Starts the operator process during application boot</li>
<li>Implements a custom Reconcile function to run on each <code>Ghost</code> resource event</li>
<li>Configures the operator to know which resource events to listen to</li>
</ol>
<p>To see the start process, navigate to <code>cmd/main.go:125</code>. You will see a section that starts the ghost operator:</p>
<pre><code class="language-shell">if err = (&amp;controllers.WebsiteReconciler{
  Client: mgr.GetClient(),
  Scheme: mgr.GetScheme(),
}).SetupWithManager(mgr); err != nil {
  setupLog.Error(err, &quot;unable to create controller&quot;, &quot;controller&quot;, &quot;Website&quot;)
  os.Exit(1)
}
</code></pre>
<p>This is a call to the function <code>SetupWithManager(mgr)</code> defined in the file <code>internal/controller/ghost_controller.go</code>.</p>
<p>Navigate to <code>internal/controller/ghost_controller.go:58</code> to view this function. 
It is already configured to know about the CRD <code>api/v1/ghost_types.go</code> or the generated yaml represenation at <code>crd/bases/blog.example.com_ghosts</code>.</p>
<p>The most important function inside the controller is the <code>Reconcile</code> function <code>internal/controller/ghost_controller.go:49</code>.  Reconcile is part of the main kubernetes reconciliation loop which aims to move the current state of the cluster closer to the desired state. It is triggered anytime we change the cluster state related to our custom resource <code>internal/controller/ghost_controller.go:49</code>.</p>
<h2 id="5-add-some-logging-to-the-reconcile-function"><a class="header" href="#5-add-some-logging-to-the-reconcile-function">5. Add Some Logging to the Reconcile Function</a></h2>
<p>let's add some logs to the reconcile function and run the operator application and change the state of the cluster.
let's paste this code into the <code>Reconcile</code> function. </p>
<pre><code class="language-go">log := log.FromContext(ctx)
log.Info(&quot;Reconciling Ghost&quot;)
log.Info(&quot;Reconciliation complete&quot;)
return ctrl.Result{}, nil
</code></pre>
<p>and run the application</p>
<pre><code class="language-shell">make run
</code></pre>
<p>next we need to modify the generated custom resource yaml file
navigate to <code>config/samples/blog_v1_ghost.yaml</code>
and add a <code>foo: bar</code> under spec. The custom resource should look like </p>
<pre><code class="language-yaml">apiVersion: blog.example.com/v1
kind: Ghost
metadata:
  name: ghost-sample
spec:
  foo: bar
</code></pre>
<p>don't forget to save the file. Now in other terminal window, let's apply it on the cluster.</p>
<pre><code class="language-shell">kubectl apply -f config/samples/blog_v1_ghost.yaml
</code></pre>
<p>Tada! checkout the logs showing up!</p>
<pre><code class="language-shell">INFO    Reconciling Ghost
INFO    Reconciliation complete
</code></pre>
<p>now let's try deleting the resource. </p>
<pre><code class="language-shell">kubectl delete -f config/samples/blog_v1_ghost.yaml
</code></pre>
<p>Same logs showed up again. So basically <em>anytime</em> you interact with your <code>Ghost</code> resource a new event is triggered and your controller will print the logs. </p>
<h2 id="6-implement-the-desired-state-of-the-ghost-operator"><a class="header" href="#6-implement-the-desired-state-of-the-ghost-operator">6. Implement the Desired State of the Ghost Operator</a></h2>
<p>Now let us replace the default GhostSpec with a meaningful declartion of our desired state. Meaning we want our custom resource reflect the desired state for our Ghost application.</p>
<p>replace GhostSpec <code>api/v1/ghost_types.go:27</code> with the following snippet</p>
<pre><code class="language-go">type GhostSpec struct {
	//+kubebuilder:validation:Pattern=`^[-a-z0-9]*$`
	ImageTag string `json:&quot;imageTag&quot;`
}
</code></pre>
<p>This code has three key parts:</p>
<p>//+kubebuilder is a comment prefix that will trigger kubebuilder generation changes. In this case, it will set a validation of the <code>ImageTag</code> value to only allow dashes, lowercase letters, or digits.
The <code>ImageTag</code> is the Golang variable used throughout the codebase. Golang uses capitalized public variable names by convention.
<code>json:&quot;imageTag&quot;</code> defines a &quot;tag&quot; that Kubebuilder uses to generate the YAML field. Yaml parameters starts with lower case variable names by convention.
If <code>omitempty</code> is used in a json tag, that field will be marked as <code>optional</code>, otherwise as <code>mandatory</code>.</p>
<p>Before we generete the new crd and install them on the cluster let's do the following, let's have a look at the existing crd</p>
<pre><code class="language-shell">kubectl get crd ghosts.blog.example.com --output jsonpath=&quot;{.spec.versions[0].schema['openAPIV3Schema'].properties.spec.properties}{\&quot;\n\&quot;}&quot; | jq
</code></pre>
<p>the output should be like </p>
<pre><code class="language-json">{
  &quot;foo&quot;: {
    &quot;description&quot;: &quot;Foo is an example field of Ghost. Edit ghost_types.go to remove/update&quot;,
    &quot;type&quot;: &quot;string&quot;
  }
}
</code></pre>
<p>now, let us install the new crd</p>
<pre><code class="language-shell">make install
</code></pre>
<p>and see the changes</p>
<pre><code class="language-shell">kubectl get crd ghosts.blog.example.com --output jsonpath=&quot;{.spec.versions[0].schema['openAPIV3Schema'].properties.spec.properties}{\&quot;\n\&quot;}&quot; | jq
</code></pre>
<p>the output should be </p>
<pre><code class="language-json">{
  &quot;imageTag&quot;: {
    &quot;pattern&quot;: &quot;^[-a-z0-9]*$&quot;,
    &quot;type&quot;: &quot;string&quot;
  }
}
</code></pre>
<h2 id="7-access-the-custom-resource-inside-the-reconcile-function"><a class="header" href="#7-access-the-custom-resource-inside-the-reconcile-function">7. Access the Custom Resource Inside the Reconcile Function</a></h2>
<p>now let's try to access our custom resource in the <code>reconcile</code> function. 
first off, let us reflect our new fields in our cutom resource.
let us replace <code>config/samples/blog_v1_ghost.yaml</code> with the following</p>
<pre><code class="language-yaml">apiVersion: blog.example.com/v1
kind: Ghost
metadata:
  name: ghost-sample
  namespace: marketing
spec:
  imageTag: latest
</code></pre>
<pre><code class="language-shell">kubectl create namespace marketing
kubectl apply -f config/samples/blog_v1_ghost.yaml
</code></pre>
<p>next, let us replace the <code>reconcile</code> code with the following snippet: </p>
<pre><code class="language-go">log := log.FromContext(ctx)
ghost := &amp;blogv1.Ghost{}
if err := r.Get(ctx, req.NamespacedName, ghost); err != nil {
  log.Error(err, &quot;Failed to get Ghost&quot;)
  return ctrl.Result{}, client.IgnoreNotFound(err)
}

log.Info(&quot;Reconciling Ghost&quot;, &quot;imageTag&quot;, ghost.Spec.ImageTag, &quot;team&quot;, ghost.ObjectMeta.Namespace)
log.Info(&quot;Reconciliation complete&quot;)
return ctrl.Result{}, nil
</code></pre>
<p>let us anlyze the above snippet line by line. 
line 1 assings a logger instance to the variable <code>log</code> variable.
line 2 creates an instance of our <code>Ghost</code> data structure.
line 3 tries to read a ghost instance from the reconciler client. Please note that the r which is a reference to the <code>GhostReconciler</code> has a k8s client interface and that interface which implements the <code>Get</code> method which is an equivalent golang implementation of the <code>kubectl get</code>. on succesful <code>Get</code> the resouce will be written to our <code>ghost</code> variable. in case of error, client logs the error. if the error is of type (not found) the controller won't return an error. error not found will happen if we run <code>kubectl delete -f config/samples/blog_v1_ghost.yaml</code></p>
<p>now we can start our application again:</p>
<pre><code class="language-shell">make run
</code></pre>
<p>so far our reconcile function is not run yet but if we apply our custom resource in another terminal window:</p>
<pre><code class="language-shell">kubectl apply -f config/crd/samples/blog_v1_ghost.yaml
</code></pre>
<p>we start to see the logs of our reconcile function</p>
<pre><code class="language-shell">INFO    Reconciling Ghost       {&quot;controller&quot;: &quot;ghost&quot;, &quot;controllerGroup&quot;: &quot;blog.example.com&quot;, &quot;controllerKind&quot;: &quot;Ghost&quot;, &quot;Ghost&quot;: {&quot;name&quot;:&quot;ghost-sample&quot;,&quot;namespace&quot;:&quot;marketing&quot;}, &quot;namespace&quot;: &quot;marketing&quot;, &quot;name&quot;: &quot;ghost-sample&quot;, &quot;reconcileID&quot;: &quot;9faf1c4f-6dcf-42d5-9f16-fbebb453b4ed&quot;, &quot;imageTag&quot;: &quot;latest&quot;, &quot;team&quot;: &quot;marketing&quot;}
2024-04-29T15:54:05+02:00       

INFO    Reconciliation complete {&quot;controller&quot;: &quot;ghost&quot;, &quot;controllerGroup&quot;: &quot;blog.example.com&quot;, &quot;controllerKind&quot;: &quot;Ghost&quot;, &quot;Ghost&quot;: {&quot;name&quot;:&quot;ghost-sample&quot;,&quot;namespace&quot;:&quot;marketing&quot;}, &quot;namespace&quot;: &quot;marketing&quot;, &quot;name&quot;: &quot;ghost-sample&quot;, &quot;reconcileID&quot;: &quot;9faf1c4f-6dcf-42d5-9f16-fbebb453b4ed&quot;}
</code></pre>
<p>cool! next stop, we will implement the actual controller logic for our ghost operator.</p>
<h2 id="8-implement-the-ghost-operator-logic-part-1---pvc"><a class="header" href="#8-implement-the-ghost-operator-logic-part-1---pvc">8. Implement the Ghost Operator Logic, Part 1 - PVC</a></h2>
<p>Before we start coding the ghost operator, we need to know what resources we need in order to deploy ghost to our cluster. let's consult the docker hub page for ghost. https://hub.docker.com/_/ghost</p>
<p>As we would like to persist ghost data to a persistent volume, we can try to convert this docker command to a k8s deployment. </p>
<pre><code class="language-shell">docker run -d \
	--name some-ghost \
	-e NODE_ENV=development \
	-e database__connection__filename='/var/lib/ghost/content/data/ghost.db' \
	-p 3001:2368 \
	-v some-ghost-data:/var/lib/ghost/content \
	ghost:alpine
</code></pre>
<p>The deployment would look something like </p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: ghost-deployment
spec:
  replicas: 1 # You can adjust the number of replicas as needed
  selector:
    matchLabels:
      app: ghost
  template:
    metadata:
      labels:
        app: ghost
    spec:
      containers:
      - name: ghost
        image: ghost:alpine
        env:
        - name: NODE_ENV
          value: development
        - name: database__connection__filename
          value: /var/lib/ghost/content/data/ghost.db
        ports:
        - containerPort: 2368
        volumeMounts:
        - name: ghost-data
          mountPath: /var/lib/ghost/content
      volumes:
      - name: ghost-data
        persistentVolumeClaim:
          claimName: ghost-data-pvc # Define your PVC or use an existing one
</code></pre>
<p>As you can see this deployment expects an existing persistent volume claim called <code>ghost-data-pvc</code></p>
<p>We can define it with this yaml:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ghost-data-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
</code></pre>
<p>In our operator, each team's ghost instance will be deployed to the team's corresponding namespace.
Let us try to code the pvc provisiong into our controller. For that we need to copy the following snippet to our controller.
<code>internal/controller/ghost_controller.go</code> </p>
<pre><code class="language-go">func (r *GhostReconciler) addPvcIfNotExists(ctx context.Context, ghost *blogv1.Ghost) error {
	log := log.FromContext(ctx)

	pvc := &amp;corev1.PersistentVolumeClaim{}
	team := ghost.ObjectMeta.Namespace
	pvcName := pvcNamePrefix + team

	err := r.Get(ctx, client.ObjectKey{Namespace: ghost.ObjectMeta.Namespace, Name: pvcName}, pvc)

	if err == nil {
		// PVC exists, we are done here!
		return nil
	}

	// PVC does not exist, create it
	desiredPVC := generateDesiredPVC(ghost, pvcName)
	if err := controllerutil.SetControllerReference(ghost, desiredPVC, r.Scheme); err != nil {
		return err
	}

	if err := r.Create(ctx, desiredPVC); err != nil {
		return err
	}
	r.recoder.Event(ghost, corev1.EventTypeNormal, &quot;PVCReady&quot;, &quot;PVC created successfully&quot;)
	log.Info(&quot;PVC created&quot;, &quot;pvc&quot;, pvcName)
	return nil
}

func generateDesiredPVC(ghost *blogv1.Ghost, pvcName string) *corev1.PersistentVolumeClaim {
	return &amp;corev1.PersistentVolumeClaim{
		ObjectMeta: metav1.ObjectMeta{
			Name:      pvcName,
			Namespace: ghost.ObjectMeta.Namespace,
		},
		Spec: corev1.PersistentVolumeClaimSpec{
			AccessModes: []corev1.PersistentVolumeAccessMode{corev1.ReadWriteOnce},
			Resources: corev1.VolumeResourceRequirements{
				Requests: corev1.ResourceList{
					corev1.ResourceStorage: resource.MustParse(&quot;1Gi&quot;),
				},
			},
		},
	}
}
</code></pre>
<p>Let's also add </p>
<pre><code class="language-go">const pvcNamePrefix = &quot;ghost-data-pvc-&quot;
const deploymentNamePrefix = &quot;ghost-deployment-&quot;
const svcNamePrefix = &quot;ghost-service-&quot;
</code></pre>
<p>right after our <code>GhostReconciler</code> struct. (around line 40).
The <code>addPvcIfNotExists</code> function, checks whether the <code>pvc</code> is already created and if not, it will create it in the right namespace.</p>
<h2 id="9-implement-the-ghost-operator-logic-part-2---rbac"><a class="header" href="#9-implement-the-ghost-operator-logic-part-2---rbac">9. Implement the Ghost Operator Logic, Part 2 - RBAC</a></h2>
<p>Next, we need to specify the kubebuilder markers for RBAC. After we created our apis there are 3 markers generated by default.</p>
<pre><code class="language-go">//+kubebuilder:rbac:groups=blog.example.com,resources=ghosts,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=blog.example.com,resources=ghosts/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=blog.example.com,resources=ghosts/finalizers,verbs=update
</code></pre>
<p>These markers with <code>//+kubebuilder</code> prefix are picked up by <code>make manfists</code> where a <code>ClusterRole</code> manifests is generated and assiged to the operator manager application. When we CRUD other APIs such as deployment, services and Persistent Volume Claims, we need to add those related markers, otherwise our operator will be unauthorized to perform those operations. In case of our operator, we need to additional markers right below the default ones at <code>internal/controller/ghost_controller.go</code>.</p>
<pre><code class="language-go">//+kubebuilder:rbac:groups=blog.example.com,resources=ghosts/events,verbs=get;list;watch;create;update;patch
//+kubebuilder:rbac:groups=&quot;&quot;,resources=persistentvolumeclaims,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=&quot;&quot;,resources=services,verbs=get;list;watch;create;update;patch;delete
</code></pre>
<p>Please note the first one, is needed when we later introduce a function to persist operator events in the ghost resource.
To generate RBAC manfiests, we can run</p>
<pre><code class="language-shell">make manifests
</code></pre>
<p>The generated manifest for the manager cluster role, will be generated at <code>config/rbac/role.yaml</code></p>
<h2 id="10-implement-the-ghost-operator-logic-part-2---deployment"><a class="header" href="#10-implement-the-ghost-operator-logic-part-2---deployment">10. Implement the Ghost Operator Logic, Part 2 - Deployment</a></h2>
<p>Next, we add the deployment create and update logic to our controller. For that we copy the following snippet to our controller.
The logic is very similar to the previous snippet. However there is one key difference and that is that <code>addOrUpdateDeployment</code> can also update a deployment in case the deployed <code>imageTag</code> for the ghost image is different from the one coming from the <code>ghost.Spec</code> aka. desired state.</p>
<pre><code class="language-go">func (r *GhostReconciler) addOrUpdateDeployment(ctx context.Context, ghost *blogv1.Ghost) error {
	log := log.FromContext(ctx)
	deploymentList := &amp;appsv1.DeploymentList{}
	labelSelector := labels.Set{&quot;app&quot;: &quot;ghost-&quot; + ghost.ObjectMeta.Namespace}

	err := r.List(ctx, deploymentList, &amp;client.ListOptions{
		Namespace:     ghost.ObjectMeta.Namespace,
		LabelSelector: labelSelector.AsSelector(),
	})
	if err != nil {
		return err
	}

	if len(deploymentList.Items) &gt; 0 {
		// Deployment exists, update it
		existingDeployment := &amp;deploymentList.Items[0] // Assuming only one deployment exists
		desiredDeployment := generateDesiredDeployment(ghost)

		// Compare relevant fields to determine if an update is needed
		if existingDeployment.Spec.Template.Spec.Containers[0].Image != desiredDeployment.Spec.Template.Spec.Containers[0].Image {
			// Fields have changed, update the deployment
			existingDeployment.Spec = desiredDeployment.Spec
			if err := r.Update(ctx, existingDeployment); err != nil {
				return err
			}
			log.Info(&quot;Deployment updated&quot;, &quot;deployment&quot;, existingDeployment.Name)
			r.recoder.Event(ghost, corev1.EventTypeNormal, &quot;DeploymentUpdated&quot;, &quot;Deployment updated successfully&quot;)
		} else {
			log.Info(&quot;Deployment is up to date, no action required&quot;, &quot;deployment&quot;, existingDeployment.Name)
		}
		return nil
	}

	// Deployment does not exist, create it
	desiredDeployment := generateDesiredDeployment(ghost)
	if err := controllerutil.SetControllerReference(ghost, desiredDeployment, r.Scheme); err != nil {
		return err
	}
	if err := r.Create(ctx, desiredDeployment); err != nil {
		return err
	}
	r.recoder.Event(ghost, corev1.EventTypeNormal, &quot;DeploymentCreated&quot;, &quot;Deployment created successfully&quot;)
	log.Info(&quot;Deployment created&quot;, &quot;team&quot;, ghost.ObjectMeta.Namespace)
	return nil
}

func generateDesiredDeployment(ghost *blogv1.Ghost) *appsv1.Deployment {
	replicas := int32(1) // Adjust replica count as needed
	return &amp;appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: deploymentNamePrefix,
			Namespace:    ghost.ObjectMeta.Namespace,
			Labels: map[string]string{
				&quot;app&quot;: &quot;ghost-&quot; + ghost.ObjectMeta.Namespace,
			},
		},
		Spec: appsv1.DeploymentSpec{
			Replicas: &amp;replicas,
			Selector: &amp;metav1.LabelSelector{
				MatchLabels: map[string]string{
					&quot;app&quot;: &quot;ghost-&quot; + ghost.ObjectMeta.Namespace,
				},
			},
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						&quot;app&quot;: &quot;ghost-&quot; + ghost.ObjectMeta.Namespace,
					},
				},
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{
						{
							Name:  &quot;ghost&quot;,
							Image: &quot;ghost:&quot; + ghost.Spec.ImageTag,
							Env: []corev1.EnvVar{
								{
									Name:  &quot;NODE_ENV&quot;,
									Value: &quot;development&quot;,
								},
								{
									Name:  &quot;database__connection__filename&quot;,
									Value: &quot;/var/lib/ghost/content/data/ghost.db&quot;,
								},
							},
							Ports: []corev1.ContainerPort{
								{
									ContainerPort: 2368,
								},
							},
							VolumeMounts: []corev1.VolumeMount{
								{
									Name:      &quot;ghost-data&quot;,
									MountPath: &quot;/var/lib/ghost/content&quot;,
								},
							},
						},
					},
					Volumes: []corev1.Volume{
						{
							Name: &quot;ghost-data&quot;,
							VolumeSource: corev1.VolumeSource{
								PersistentVolumeClaim: &amp;corev1.PersistentVolumeClaimVolumeSource{
									ClaimName: &quot;ghost-data-pvc-&quot; + ghost.ObjectMeta.Namespace,
								},
							},
						},
					},
				},
			},
		},
	}
}
</code></pre>
<p>Let's make sure <code>apps/v1</code> import statement is added to the import section.</p>
<pre><code class="language-go">appsv1 &quot;k8s.io/api/apps/v1&quot;
</code></pre>
<h2 id="11-implement-the-ghost-operator-logic-part-3---service"><a class="header" href="#11-implement-the-ghost-operator-logic-part-3---service">11. Implement the Ghost Operator Logic, Part 3 - Service</a></h2>
<p>And Lastly we need to add a service for our deployment. For now let's choose a service of type <code>NodePort</code></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: ghost-service
spec:
  type: NodePort
  ports:
    - port: 80 # Exposed port on the service
      targetPort: 2368 # Port your application is listening on inside the pod
      nodePort: 30001 # NodePort to access the service externally
  selector:
    app: ghost
</code></pre>
<p>Next, we need to implement a go funtion that creates such service for us.</p>
<pre><code class="language-go">func (r *GhostReconciler) addServiceIfNotExists(ctx context.Context, ghost *blogv1.Ghost) error {
	log := log.FromContext(ctx)
	service := &amp;corev1.Service{}
	err := r.Get(ctx, client.ObjectKey{Namespace: ghost.ObjectMeta.Namespace, Name: svcNamePrefix + ghost.ObjectMeta.Namespace}, service)
	if err != nil &amp;&amp; client.IgnoreNotFound(err) != nil {
		return err
	}

	if err == nil {
		// Service exists
		return nil
	}
	// Service does not exist, create it
	desiredService := generateDesiredService(ghost)
	if err := controllerutil.SetControllerReference(ghost, desiredService, r.Scheme); err != nil {
		return err
	}

	// Service does not exist, create it
	if err := r.Create(ctx, desiredService); err != nil {
		return err
	}
	r.recoder.Event(ghost, corev1.EventTypeNormal, &quot;ServiceCreated&quot;, &quot;Service created successfully&quot;)
	log.Info(&quot;Service created&quot;, &quot;service&quot;, desiredService.Name)
	return nil
}

func generateDesiredService(ghost *blogv1.Ghost) *corev1.Service {
	return &amp;corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      &quot;ghost-service-&quot; + ghost.ObjectMeta.Namespace,
			Namespace: ghost.ObjectMeta.Namespace,
		},
		Spec: corev1.ServiceSpec{
			Type: corev1.ServiceTypeNodePort,
			Ports: []corev1.ServicePort{
				{
					Port:       80,
					TargetPort: intstr.FromInt(2368),
					NodePort:   30001,
				},
			},
			Selector: map[string]string{
				&quot;app&quot;: &quot;ghost-&quot; + ghost.ObjectMeta.Namespace,
			},
		},
	}
}
</code></pre>
<h2 id="12-implement-the-final-logic-of-the-reconcile-function"><a class="header" href="#12-implement-the-final-logic-of-the-reconcile-function">12. Implement the Final Logic of the Reconcile Function</a></h2>
<p>Next we need to call our function in our reconcile function. We start by calling the functions we added one by one. 
In case there is an error we update the status of our ghost deployment. For that, we need to make a couple of adjustments first.
First we replace <code>GhostStatus</code> in <code>api/v1/ghost_types.go</code> with the following</p>
<pre><code class="language-go">type GhostStatus struct {
    Conditions []metav1.Condition `json:&quot;conditions,omitempty&quot;`
}
</code></pre>
<p>and we add two helper functions to our controller. <code>internal/controller/ghost_controller.go</code></p>
<pre><code class="language-go">// Function to add a condition to the GhostStatus
func addCondition(status *blogv1.GhostStatus, condType string, statusType metav1.ConditionStatus, reason, message string) {
	for i, existingCondition := range status.Conditions {
		if existingCondition.Type == condType {
			// Condition already exists, update it
			status.Conditions[i].Status = statusType
			status.Conditions[i].Reason = reason
			status.Conditions[i].Message = message
			status.Conditions[i].LastTransitionTime = metav1.Now()
			return
		}
	}

	// Condition does not exist, add it
	condition := metav1.Condition{
		Type:               condType,
		Status:             statusType,
		Reason:             reason,
		Message:            message,
		LastTransitionTime: metav1.Now(),
	}
	status.Conditions = append(status.Conditions, condition)
}

// Function to update the status of the Ghost object
func (r *GhostReconciler) updateStatus(ctx context.Context, ghost *blogv1.Ghost) error {
	// Update the status of the Ghost object
	if err := r.Status().Update(ctx, ghost); err != nil {
		return err
	}

	return nil
}
</code></pre>
<p>And finally our reconcile function should be replaced with the following snippet.</p>
<pre><code class="language-go">func (r *GhostReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)
	ghost := &amp;blogv1.Ghost{}
	if err := r.Get(ctx, req.NamespacedName, ghost); err != nil {
		log.Error(err, &quot;Failed to get Ghost&quot;)
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}
	// Initialize completion status flags
	// Add or update the namespace first
	pvcReady := false
	deploymentReady := false
	serviceReady := false
	log.Info(&quot;Reconciling Ghost&quot;, &quot;imageTag&quot;, ghost.Spec.ImageTag, &quot;team&quot;, ghost.ObjectMeta.Namespace)
	// Add or update PVC
	if err := r.addPvcIfNotExists(ctx, ghost); err != nil {
		log.Error(err, &quot;Failed to add PVC for Ghost&quot;)
		addCondition(&amp;ghost.Status, &quot;PVCNotReady&quot;, metav1.ConditionFalse, &quot;PVCNotReady&quot;, &quot;Failed to add PVC for Ghost&quot;)
		return ctrl.Result{}, err
	} else {
		pvcReady = true
	}
	// Add or update Deployment
	if err := r.addOrUpdateDeployment(ctx, ghost); err != nil {
		log.Error(err, &quot;Failed to add or update Deployment for Ghost&quot;)
		addCondition(&amp;ghost.Status, &quot;DeploymentNotReady&quot;, metav1.ConditionFalse, &quot;DeploymentNotReady&quot;, &quot;Failed to add or update Deployment for Ghost&quot;)
		return ctrl.Result{}, err
	} else {
		deploymentReady = true
	}
	// Add or update Service
	if err := r.addServiceIfNotExists(ctx, ghost); err != nil {
		log.Error(err, &quot;Failed to add Service for Ghost&quot;)
		addCondition(&amp;ghost.Status, &quot;ServiceNotReady&quot;, metav1.ConditionFalse, &quot;ServiceNotReady&quot;, &quot;Failed to add Service for Ghost&quot;)
		return ctrl.Result{}, err
	} else {
		serviceReady = true
	}
	// Check if all subresources are ready
	if pvcReady &amp;&amp; deploymentReady &amp;&amp; serviceReady {
		// Add your desired condition when all subresources are ready
		addCondition(&amp;ghost.Status, &quot;GhostReady&quot;, metav1.ConditionTrue, &quot;AllSubresourcesReady&quot;, &quot;All subresources are ready&quot;)
	}
	log.Info(&quot;Reconciliation complete&quot;)
	if err := r.updateStatus(ctx, ghost); err != nil {
		log.Error(err, &quot;Failed to update Ghost status&quot;)
		return ctrl.Result{}, err
	}

	return ctrl.Result{}, nil
}
</code></pre>
<p>now, let us run our operator application. before we do that let's make sure we are starting from scratch.</p>
<pre><code class="language-shell">kubectl delete namespace marketing
</code></pre>
<pre><code class="language-shell">make run
</code></pre>
<p>we can see the logs and see that our operator application is up and running, 
in another termainl we create a ghost resource.</p>
<pre><code class="language-shell">kubectl create namespace marketing
kubectl apply -f config/samples/blog_v1_ghost.yaml
</code></pre>
<p>We start to see our reconciliation logs showing up and our subresources being created. We can inspect them by running <code>k9s</code>.
We can perform a portforward on the service to see our ghost application in a browser.
Let's have a look at our ghost resource as well.</p>
<pre><code class="language-shell">kubectl describe -n marketing ghosts.blog.example.com ghost-sample
</code></pre>
<h2 id="13-update-the-ghost-resource"><a class="header" href="#13-update-the-ghost-resource">13. Update the Ghost Resource</a></h2>
<p>let us perform an update on our resource and use the <code>alpine</code> image tag instead of <code>latest</code>.
So, let us replace <code>config/samples/blog_v1_ghost.yaml</code> with the following and apply it.</p>
<pre><code class="language-yaml">apiVersion: blog.example.com/v1
kind: Ghost
metadata:
  name: ghost-sample
  namespace: marketing
spec:
  imageTag: alpine
</code></pre>
<pre><code class="language-shell">kubectl apply -f config/samples/blog_v1_ghost.yaml
</code></pre>
<p>We can see that our deployment subresource is being updated and the update logs are showing up in the console. We can confirm this by inspecting the deployment in <code>k9s</code>.</p>
<h2 id="14-deleting-the-ghost-resource"><a class="header" href="#14-deleting-the-ghost-resource">14. Deleting the ghost resource</a></h2>
<p>If perform a delete operation on our resource, all the subresouces will be deleted too, as we set their owner to be the ghost resource.
Please notice the <code>controllerutil.SetControllerReference</code> usage, before creating the subresources.</p>
<p>Let us perform the delete and see the effect.</p>
<pre><code class="language-shell">kubectl delete ghosts.blog.example.com -n marketing ghost-sample
</code></pre>
<p>We can see all the subresources are deleted.</p>
<pre><code class="language-shell">kubectl get all -n marketing
</code></pre>
<h2 id="15-deploy-ghost-operator-to-the-cluster"><a class="header" href="#15-deploy-ghost-operator-to-the-cluster">15. Deploy Ghost Operator to the Cluster</a></h2>
<p>Your operator is an application, so it needs to be packaged as a OCI compliant container image just like any other container you want to deploy.</p>
<p>We need to run the right make command to build our OCI image and then Deploy it.</p>
<p>Build</p>
<pre><code class="language-shell"># please use your own tag here! :D 
export IMG=c8n.io/aghilish/ghost-operator:latest
make docker-build
</code></pre>
<p>Push</p>
<pre><code class="language-shell">make docker-push
</code></pre>
<p>Deploy</p>
<pre><code class="language-shell">make deploy
</code></pre>
<p>Undeploy</p>
<pre><code class="language-shell">make undeploy
</code></pre>
<p>And we can look around and inspect the logs of our manager when we CRUD operations with our ghost API.</p>
<pre><code class="language-shell">kubectl get all -n ghost-operator-system
</code></pre>
<h2 id="16-bonus-setup-vscode-debugger"><a class="header" href="#16-bonus-setup-vscode-debugger">16. [Bonus] Setup VSCode Debugger</a></h2>
<p>Being able to run our operator application in debug mode is definitely a nice thing. 
Fortutanly we can simply do this on vscode. Let's click on the <code>create a launch.json file</code> in the <code>Run and Debug</code>.
<img src="../assets/launchjson.png" alt="vscode run and debug" width="70%"></p>
<p>Next we select <code>Go</code> and <code>Go Launch Package</code>. In the generated json file we need to adjust the program argument and set it to the 
main.go file of our application which is at <code>cmd/main.go</code>.</p>
<pre><code class="language-json">{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Launch Package&quot;,
            &quot;type&quot;: &quot;go&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;mode&quot;: &quot;auto&quot;,
            &quot;program&quot;: &quot;${fileDirname}/cmd/main.go&quot;
        }
    ]
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../advanced/operators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../tutorials/serverless.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../advanced/operators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../tutorials/serverless.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
